反射

Java程序中，所有的对象都有两种类型：`编译时类型`和`运行时类型`，而很多时候对象的编译时类型和运行时类型`不一致`。
   Object obj = new String("hello");    obj.getClass()

例如：某些变量或形参的声明类型是Object类型，但是程序却需要调用该对象运行时类型的方法，
     该方法不是Object中的方法，那么如何解决呢？

解决这个问题，有两种方案：

方案1：在编译和运行时都完全知道类型的具体信息，在这种情况下，
      我们可以直接先使用`instanceof`运算符进行判断，再利用强制类型转换符将其转换成运行时类型的变量即可。

方案2：编译时根本无法预知该对象和类的真实信息，
      程序只能依靠`运行时信息`来发现该对象和类的真实信息，这就必须使用反射。



反射被视为动态语言，反射机制允许程序在运行期间借助于 Reflection API 取得任何类的内部信息，
并且可以直接操作类的内部属性以及方法

Java反射机制提供的功能：
- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时获取泛型信息
- 在运行时调用任意一个对象的成员变量和方法
- 在运行时处理注解
- 生成动态代理