反射

Java程序中，所有的对象都有两种类型：`编译时类型`和`运行时类型`，而很多时候对象的编译时类型和运行时类型`不一致`。
   Object obj = new String("hello");    obj.getClass()

例如：某些变量或形参的声明类型是Object类型，但是程序却需要调用该对象运行时类型的方法，
     该方法不是Object中的方法，那么如何解决呢？

解决这个问题，有两种方案：

方案1：在编译和运行时都完全知道类型的具体信息，在这种情况下，
      我们可以直接先使用`instanceof`运算符进行判断，再利用强制类型转换符将其转换成运行时类型的变量即可。

方案2：编译时根本无法预知该对象和类的真实信息，
      程序只能依靠`运行时信息`来发现该对象和类的真实信息，这就必须使用反射。



反射被视为动态语言，反射机制允许程序在运行期间借助于 Reflection API 取得任何类的内部信息，
并且可以直接操作类的内部属性以及方法

Java反射机制提供的功能：
- 在运行时判断任意一个对象所属的类
- 在运行时构造任意一个类的对象
- 在运行时判断任意一个类所具有的成员变量和方法
- 在运行时获取泛型信息
- 在运行时调用任意一个对象的成员变量和方法
- 在运行时处理注解
- 生成动态代理



1. 面向对象中创建对象，调用指定结构（属性、方法）等功能，可以不使用反射，也可以使用反射。请问有什么区别？
        不使用反射，我们需要考虑封装性。比如：出了Person类之后，就不能调用Person类中私有的结构
        使用反射，我们可以调用运行时类中任意的构造器、属性、方法。包括了私有的属性、方法、构造器。
2. 以前创建对象并调用方法的方式，与现在通过反射创建对象并调用方法的方式对比的话，哪种用的多？
   场景是什么？
        > 从我们作为程序员开发者的角度来讲，我们开发中主要是完成业务代码，对于相关的对象、方法的调用都是确定的。
          所以，我们使用非反射的方式多一些。
        > 因为反射体现了动态性（可以在运行时动态的获取对象所属的类，动态的调用相关的方法），所以我们在设计框架的时候，
          会大量的使用反射。意味着，如果大家需要学习框架源码，那么就需要学习反射。
          框架 = 注解 + 反射 + 设计模式
3. 单例模式的饿汉式和懒汉式中，私有化类的构造器了！ 此时通过反射，可以创建单例模式中类的多个对象吗？
        是的！
4. 通过反射，可以调用类中私有的结构，是否与面向对象的封装性有冲突？是不是Java语言设计存在Bug？
        不存在bug!
        封装性：体现的是是否建议我们调用内部api的问题。比如，private声明的结构，意味着不建议调用。
        反射：体现的是我们能否调用的问题。因为类的完整结构都加载到了内存中，所有我们就有能力进行调用


