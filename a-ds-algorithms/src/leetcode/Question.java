package leetcode;

import java.util.*;

/**
 * ClassName: test.Question
 * Package: PACKAGE_NAME
 * Description:
 *
 * @Author jieHFUT
 * @Create 2025/8/4 8:09
 * @Version 1.0
 */
public class Question {

    public static void main(String[] args) {

//        List<Integer> list = new ArrayList<>();
//        list.add(1);
//        list.add(2);
//        list.add(3);
//        list.add(4);
//        list.add(5);
//        list.add(6);
//        System.out.println(list);
//
//        System.out.println("0123456789".substring(1)); // 123456789
//        System.out.println("0123456789".substring(1, 9)); // 12345678
//        "weiohf".length();
//        StringBuilder ret = new StringBuilder();
//        System.out.println(" +24353".trim());
//        Character.isDigit('t');
//        char ch = '8' - '0';
//        System.out.println("ch = " + ch);
//
//        System.out.println(Integer.MAX_VALUE);
//        System.out.println(Integer.MIN_VALUE);
//
//        int digit = '9' - '0';
//        System.out.println("digit = " + digit);
//        System.out.println((char) digit);
//        System.out.println(Math.abs(-5));
//
//        String str;
//        str = "swqd";
//        System.out.println(str);
//
//
//        List<String> strs1 = new ArrayList<>();
//        List<String> strs2 = new ArrayList<>();
//        strs2.add("1");
//        strs2.add("2");
//        strs2.add("3");
//        System.out.println("strs1.size() = " + strs1.size());
//        List<String> strs3 = new ArrayList<>();
//        for (String str1 : strs1) {
//            for (String str2 : strs2) {
//                strs3.add(str1 + str2);
//            }
//        }
//        System.out.println("strs3.size() = " + strs3.size());

//        String[] strss = {"1", "2", "3", "4", "5", "6", "7", "8", "9"};
//        for (String s : strss) {
//            System.out.println(s);
//        }

//        Stack<Integer> stack = new Stack<>();
//        int[] point = new int[2];
//        Arrays.fill(point, 0);
//
//        int[] nums = {1,2,4,2315,4,36,457,65,87};
//        Arrays.sort(nums);

//        System.out.println(Integer.MIN_VALUE);
//        Stack stack = new Stack();
//
//        Queue<Character> queue = new LinkedList<>();
//
//        List<Integer> list = Arrays.asList(1, 2, 3, 43, 45);
//        Arrays.asList(new int[]{123,4,5,43,65,36,54,6});

//        String[] words = {"dqw", "qdwed", "dqwfd"};
//        List<String> list = new ArrayList<>();
//        for (String word : words) {
//            list.add(word);
//        }
//
//        System.out.println(list);

//        List<Integer> list = findSubstring("fffffffffffffffffffffffffffffffff", new String[]{"a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a"});
//        System.out.println(list);
//        List<String> rest = new  ArrayList();
//        for (String str : new String[]{"a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a"}) {
//            rest.add(str);
//        }
//        List<String> all = new ArrayList<>();
//        findAll(rest, new StringBuilder(), all);
//        System.out.println(all);

//        int[] arr = new int[]{1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10};
//        nextPermutation(arr);
//        System.out.println(Arrays.toString(arr));

//        int i = longestValidParentheses2("((((((((((((((((((((" +
//                "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((" +
//                "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((()())))(())()())((((()())((())))((()))()())))()(()()()(()((()))()()()))()()()(()()((((())()(((()(((())((()))()((()(()))()())))))))))())()())(()()))((()()()()())))((()()((((()()))))(())())()()))))(())()(()))((((((()))(()()()()(())(()((()))(()(())(((()()))(()((((()((((()((((())(())))()(())))()))(()((((((((())()()((())((()())()))))())())()(((((()()(((((())()((()(((()))(()(()))(()(()())))())(()((((()((()(((((()()))((()(()((())()))))(()(()())((()((()((((())))(()())()))()())())()))))(())))(())()((())(()(()))))()())(((()(()(((((((((()(()()())))((()((()())())())(((((()(()))))()))()))))()())()(()(())))(()))))(()))(((()))))())))))(((())((())((((()((()))((())))()))(((()))())()))()()()((()()(()())(()))()()((()())))))())(()())(((())))))())(())()))()())())(()(()((())((()(()((())(()()()(()((()(((()(())()(((())))))()())))))(()((((()(()()))(((())(()))(()()))))(())()((()))()))()()))()((())(()())())())(()))(()()(())()(()((((()())(((())(()()())())(()()))())))(()((())(()()))))(()))((()()((((()())(()()))()())()())))()(()((((())())()(())()))()()(()(()))))))(((()()((()))(()((((()()((())))())())))()())))())))((())()()()))()((()((()))()()())))(())())(()(()(()(()))())()))(())((())()())(((()()(((())(()()))(()())(())))()))(((()()()())))())))(((()))())())())))(((()))()())())())))))()()()()(())))(()())))(()()())))()((((()()()((((()))()())))(()))()))))(()())()))(((((())()((())()))(()())()()()())()(((()(()(())))))(()(((()()))((((()()))()))(((())(()(()))()(())))()()(()))))()))))()())))()))((((((((()()())((()(()()()(((())())())))()()(())(())))()())()())))((()))((((())()()))(())(((())(()()(((((()()((()()(((()(()()(((())()))))()(()())(()((((()()())(((()))(())((())()))))())))))(()()()())))()))(())((()())()())()()))(())))((()))()()((()())()()))(()()(())()())(())))((()(((())))()))))((((()))((())())())()(())(()))((((((())()()(((((()))()())(((()(()(())()((()())))(((())(()(())))))(()(()(((()))(())((((())))((())((((((((()(((((()(())))((((((())(()((((()(())()()((())())())((((((((()))))(((())()))()()))(())(())()()())(()()((())(()))())(((())(()((())(())(())))))(()(()(()()(((()()()))())(()))(())())()(((()((())((()())()(((((()()(()))))(((())()()))(()(()(()(()((())))))))(())())()))()(()(()))))()()((((())()())(((())(()))((()())(()((())()()(())((((())))))(())())())(())(()()(()()))(((()((((())(((())))))(()()()()(((()((((())(()))((())()))()(((((((()(()())))((()()(()()((())()))()(())))((()()((((()()()))((())()))((())(((()(()()()(((()((())((())()())())))((()))))))))))(())()()(((()()())))(((()))(()))))(((()(()())(()))(())((()))(((()(()()(((((((()())((((()))((((()(()())())()(((()(()((()))))))))))()()(((()()((((((((((())))))((((())())((()(((()())()))()()(((((())(()())())(((()((())((((((())(((())(((()(()(((((((()(())()())(()))))(()(((()))))))()))(((())))(()(()())()))(()()(()(()((()())()(())((()()((()()()(()(()()))(((((())()(()())()((()())()))(((((()((())()((()((((()(((())())(()()(())()(())(()(())))))(()())((()((()()()())(()))(()))))))(()((())(())((())()())()()))(()((()))(()()))()())(())(()()(()))((())()((())((((((())()(()()(((((())(()())())())()()(()())))))()))()((())((((((()())((()))))))((()(()()(((((((())))))))((()))(())(((()(()(())()()()()(()(())()))))))())()))()(((((()(())(((()))((()))()))()()(()(()((())(()))))()())((()())))))))(()()(()()))()((()(())()((())(()()))())((()())())()()))))((((()()()))())(())()())))()))()))))()))((()(()())()))()))(((()()()()())))())()))((()()())((()())))(((()((()()())(())))()(())(()(()(())(()(((((()()()(((())()())(()((()())(()(((()(())((((()())()(())))(((((((()))))())())))(()))()()(((()())(()))()())(())()))()((())()((())((()((())()())(()()))(((((()()()((((((((()(()((()()((((((()())))((((((())))())(()(()((((()(()())())()()))()((())())(()((((()(((()())((())))))(()())(()()()(()))()())()()))((()((()())(())()()()((())()()))))())()))())))(()))(()))()))((())()((()((()))))))())(((()))))))()(((()((())))((()())())()))((()(()(()(()))((()()))())))(()())))())(()))(())(())))))()(())(()()))()))((())))(()))(()))))(())()())(()(()))())(()(())(())))(()))())(()())))())(()())((()))()()((()(()()()(((((()((()((())(()())(())))()))))))(((())())))()((((()))()((()))())()))()))(()(()((()()())()()(((()))())))))()((((()()))))()))())))()())))(((((()(())))())(((()))((()))(((()(())())()((()(((()))()())))))((((()))()(()((((((()(()()()())(())((()))()(()()))))))()(((())))(())()())))))((()))(())()))))(()(((()()((())(()))))(((((()))))())))()(())(()(()))()))()))(()((())(()((()())()(((()))))())(())()(())))((())(()(((()))(((((()))(()))())))(()((((((())()((((())())()))((())))))())(()(())())))))()()(((())()())))))()))()())))()(())())(())()()()(((())))(())(((()))(()(((()()))())((()))(((()()()()())()()))(()))))()()))))(((()()))))()()(()()))()()()())())()((())(((()())(((())(()((()(((()(()())()()()(()((())(()()(()()()))))))()((()))))()(()))()))(())()()())))()()(((()))((()()(((()())))((()()())((())))))()())()((())))())(()())()()()()((())((()()())((()()))())(())())()(()(((()))())(()))))(()()))(())))))))()())()((()())()()))()())))((()()(()())()(()))((())()))(((())))())))(((()()())())(");
//        System.out.println(i);
//
//        StringBuilder str = new StringBuilder();
//        str.append(3452);
//        System.out.println(str);

//        StringBuilder str = new StringBuilder();
//        str.insert(0, 9);
//        System.out.println(str);


    }

    public int longestValidParentheses1(String s) {
        // 思路：使用一个队列来存储括号，队列的出口处一定是 '('
        // 如果再最底部是 '(' 的前提下，每入一个括号需要判断当前的状态
        // 如果左括号的数量 = 右括号的数量 => 要入的是左括号可以接着放，
        //                                  要入的是右括号的话，需要从底部移除括号，直到 peek 是左括号并且 left < right，可以入右括号
        // 如果左括号的数量大于右括号的数量，直接将该括号入栈
        Queue<Character> queue = new LinkedList();

        int left = 0;
        int right = 0;
        int maxSize = 0;

        for (int i = 0; i < s.length(); i++) {

            char ch = s.charAt(i);
            // 先寻找一个左括号入栈
            if (ch == '(') {
                // 是一个左括号
                queue.offer(ch);
                left++;
            } else {
                // 是一个右括号
                if (queue.isEmpty()) {
                    // 如果是右括号但是栈是空的
                    continue;
                } else {
                    // 栈不是空的，判断左右括号的数量
                    if (left > right) {
                        queue.offer(ch);
                        right++;
                        // 只在添加右括号的时候比较最大值，判断是不是正确的
                        if (isRight(queue) && (left + right) > maxSize) {
                            maxSize = left + right;
                        }

                    } else {
                        // 左括号的数量小于等于右括号，需要出队列
                        while (!queue.isEmpty()) {
                            if (left > right && queue.peek() == '(') {
                                // 不用在出队列了
                                break;
                            }
                            if (queue.poll() == '(') {
                                left--;
                            } else {
                                right--;
                            }
                        }
                        // 如果一直不满足条件就出到空位置，就要寻找下一个左括号
                        if (queue.isEmpty()) {
                            // 也不用入右括号了
                            continue;
                        } else {
                            // 满足了条件，该右括号入队列
                            queue.offer(ch);
                            right++;
                            // 只在添加右括号的时候比较最大值，判断是不是正确的
                            if (isRight(queue) && (left + right) > maxSize) {
                                maxSize = left + right;
                            }

                        }
                    }
                }
            }
        }
        return maxSize;
    }

    public boolean isRight(Queue<Character> queue) {
        // 遍历 queue
        Stack<Character> stack = new Stack();
        for (char ch : queue) {
            if (ch == '(') {
                stack.push(ch);
            } else {
                if (stack.isEmpty() || stack.pop() != '(') {
                    return false;
                }
            }
        }
        if (stack.isEmpty()) {
            return true;
        }
        return false;
    }









    public static int longestValidParentheses2(String s) {
        // 思路：对每一个左括号都去遍历一遍，每次到右括号停下来
        //      如果右括号的数量大于左括号，break，否则就判断 isRight2()
        int maxSize = 0;

        for (int i = 0; i < s.length(); i++) {
            // 寻找每一个左括号
            if (s.charAt(i) == '(') {
                // 从该位置开始去找右括号
                int left = 1;
                int right = 0;
                for(int j = i + 1; j < s.length(); j++) {
                    if (s.charAt(j) == '(') {
                        left++;
                    } else {
                        // 是右括号
                        right++;
                        if (right > left) {
                            break;
                        } else {
                            // 判断是否是合法的
                            if ((j - i + 1) > maxSize && isRight2(i, j, s)) {
                                maxSize = j - i + 1;
                            }
                        }
                    }
                }
            }
        }
        return maxSize;
    }

    public static boolean isRight2(int left, int right, String s) {

        Stack<Character> stack = new Stack();
        for (int i = left; i <= right; i++) {
            char ch = s.charAt(i);
            if (ch == '(') {
                stack.push(ch);
            } else {
                if (stack.isEmpty() || stack.pop() != '(') {
                    return false;
                }
            }
        }
        if (!stack.isEmpty()) {
            return false;
        }
        return true;

    }

    public static int longestValidParentheses(String s) {
        // 思路：使用一个队列来存储括号，队列的出口处一定是 '('
        // 如果再最底部是 '(' 的前提下，每入一个括号需要判断当前的状态
        // 如果左括号的数量 = 右括号的数量 => 要入的是左括号可以接着放，
        //                                  要入的是右括号的话，需要从底部移除括号，直到 peek 是左括号并且 left < right，可以入右括号
        // 如果左括号的数量大于右括号的数量，直接将该括号入栈

        Queue<Character> queue = new LinkedList();

        int left = 0;
        int right = 0;
        int maxSize = 0;

        for (int i = 0; i < s.length(); i++) {

            char ch = s.charAt(i);
            // 先寻找一个左括号入栈
            if (ch == '(') {
                // 是一个左括号
                queue.offer(ch);
                left++;
            } else {
                // 是一个右括号
                if (queue.isEmpty()) {
                    // 如果是右括号但是栈是空的
                    continue;
                } else {
                    // 栈不是空的，判断左右括号的数量
                    if (left > right) {
                        queue.offer(ch);
                        right++;
                        // 只在添加右括号的时候并且左右括号数量相等的时候比较最大值
                        if (2 * right > maxSize) {
                            maxSize = 2 * right;
                        }
                    } else {
                        // 左括号的数量小于等于右括号，需要出队列
                        while (!queue.isEmpty()) {
                            if (left > right && queue.peek() == '(') {
                                // 不用在出队列了
                                break;
                            }
                            if (queue.poll() == '(') {
                                left--;
                            } else {
                                right--;
                            }
                        }
                        // 如果一直不满足条件就出到空位置，就要寻找下一个左括号
                        if (queue.isEmpty()) {
                            // 也不用入右括号了
                            continue;
                        } else {
                            // 满足了条件，该右括号入队列
                            queue.offer(ch);
                            right++;
                            // 只在添加右括号的时候并且左右括号数量相等的时候比较最大值
                            if (2 * right > maxSize) {
                                maxSize = 2 * right;
                            }
                        }
                    }
                }
            }
        }
        return maxSize;
    }

    public static void nextPermutation(int[] nums) {
        // 思路：从后面往前遍历，只去比较最高位
        // 从后往前找最高位变小的（如果最高位相同就寻找下一位）
        // 比较规则：
        // 1.先比较最高位，如果最高位小于后面的就进行交换
        // 2.如果最高位大于后面的就移动往前继续寻找
        // 3.如果最高位等于后面的，就要比较次高位
        // 4.如果某一个数字没有次高位，那么其次高位就是其最高位
        // 5.如果两个数字完全一样也移动

        boolean flag = false;

        for (int i = nums.length - 1; i >= 0; i--) {

            if (i == 0) {
                flag = true;
                break;
            }
            int right = nums[i];
            int left = nums[i-1];

            if (left == right) {
                continue;
            }

            boolean isWasp = isSwap(nums[i - 1], nums[i]);
            if (isWasp) {
                int j = 0;
                // 需要进行交换（找到前面的大于 i-1 的最小值交换，然后 i-1 后面的所有数据进行倒序）
                for (j = i; j < nums.length; j++) {

                    if (!isSwap(nums[i-1], nums[j])) {
                        // 找到了需要交换的数据 j-1 位置
                        swap(i-1, j, nums); // 然后对 i 开始及其往后的位置倒序
                        reverse(i, nums);
                        return;
                    }

                }
                if (j == nums.length) {
                    // 没有比 i-1 位置的数值更加小的数据了，就直接和最后一位进行交换，然后直接返回
                    swap(i-1, nums.length - 1, nums);
                    reverse(i, nums);
                    return;
                }
            }
        }
        // 如果是最大值，只要对数据进行排序即可
        if (flag) {
            // 需要返回从小到大的排序
            Arrays.sort(nums);
        }
    }


    // 获取一个数字的最高位
    public static int highest(int num) {
        if (num < 10) return num;
        if (num == 100) return 1;
        return num / 10;
    }

    // 进行交换
    public static void swap(int i, int j, int[] arr) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // 去除最高位，如果只有一位数，就不变
    public static int removeHighest(int num) {
        if (num == 100) {
            return 0;
        } else if (num > 9) {
            return num % 10;
        } else {
            return num;
        }
    }

    // 两个不同的数字是否需要交换
    public static boolean isSwap(int left, int right) {
        if (left == right) {
            return false;
        }
        while (true) {
            if (highest(left) < highest(right)) {
                // 进行交换
                return true;
            } else if (highest(left) > highest(right)) {
                // i 到下一个元素
                return false;
            } else {
                // 两个元素的最高位一样，需要比较次高位
                left = removeHighest(left);
                right = removeHighest(right);
            }
        }
    }

    // 从某一个位置开始对数组后面的数据进行交换
    public static void reverse(int start, int[] array) {
        // 从 start 位置进行倒序：双指针
        int left = start;
        int right = array.length - 1;
        while (left < right) {
            // 对两个数据进行位置交换
            swap(left, right, array);

            left++;
            right--;
        }
    }





    public static List<Integer> findSubstring(String s, String[] words) {
        // 思路：先找 words 可以组成的所有字符串集合，然后使用 KMP 算法进行验证
        List<String> rest = new  ArrayList();
        for (String str : words) {
            rest.add(str);
        }

        // 1.使用回溯来寻找所有的字符串集合
        List<String> all = new ArrayList<>();
        findAll(rest, new StringBuilder(), all);
        System.out.println(all);


        // 2.对找到的所有字符串进行去重
        HashSet<String> set = new HashSet(all);
        List<String> rem = new ArrayList(set);
        System.out.println(rem);


        // 通过 KMP 算法进行判断
        List<Integer> ans = new ArrayList();

        for (String every : rem) {
            List<Integer> nums = kmp(s, every);
            if (nums.size() > 0) {
                ans.addAll(nums);
            }
        }
        return ans;
    }

    /**
     * rest：目前数组集合中还剩下的字符串
     * str：目前已经使用的字符串组成的数组
     * list：用来记录全部字符串都连接的一个结果
     */
    public static void findAll(List<String> rest, StringBuilder str, List<String> list) {
        if (rest.isEmpty()) {
            // 找到一个结果
            list.add(str.toString());
            return;
        }

        // rest 内还有元素，遍历依次添加
        for (int i = 0; i < rest.size(); i++) {
            StringBuilder builder = new StringBuilder(str);
            builder.append(rest.get(i));
            List<String> every = new ArrayList(rest);
            every.remove(i);
            findAll(every, builder, list);
        }
    }

    // 获取匹配值数组
    public static int[] getNext(String str) {
        int[] next = new int[str.length()];
        next[0] = 0;
        for (int i = 1, j = 0; i < next.length; i++) {
            // 2.如果不匹配了
            while (j > 0 && str.charAt(i) != str.charAt(j)) {
                j = next[j - 1];
            }

            // 1.先任由 i++，找到和首字母匹配的字符
            if (str.charAt(i) == str.charAt(j)) {
                j++;
            }
            next[i] = j;
        }
        return next;
    }

    // 考虑需要返回所有符合的下标
    public static List<Integer> kmp(String origin, String toFind) {
        int[] next = getNext(toFind);
        List<Integer> ans = new ArrayList();

        // i 是遍历 origin 的下标，j 是指向 toFind 的下标
        for (int i = 0, j = 0; i < origin.length(); i++) {

            // 3.如果某一个字符不匹配了
            while (j > 0 && origin.charAt(i) != toFind.charAt(j)) {
                j = next[j-1];
            }

            // 1.先找到和首字母匹配的 i 下标
            if (origin.charAt(i) == toFind.charAt(j)) {
                j++;
            }

            // 2.判断结束标志
            if (j == toFind.length()) {
                ans.add(i - j + 1);
                // 再次从头找
                if (i + 1 < origin.length()) {
                    j = next[j-1];
                }
                while (j > 0 && i + 1 < origin.length() && origin.charAt(i + 1) != toFind.charAt(j)) {
                    j = next[j - 1];
                }
            }
        }
        return ans;
    }



    public int romanToInt(String s) {
        // 给定一个罗马数字，将其转换为整数 (1<=s.length<=15)
        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] symbols = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};

        // 遍历字符串 s，优先判断前两个字符是否符合，然后再判断一个字符是否符合
        int compareIndex = 0; // 比较的下标走到哪里了（上一次哪一个符合成功了，就遍历到哪个位置）
        int ret = 0;
        String str;
        while (s.length() >= 2) {
            str = new String(new char[]{s.charAt(0), s.charAt(1)});
            str = new StringBuilder().append(s.charAt(0)).toString();

        }
        return 0;
    }



}

