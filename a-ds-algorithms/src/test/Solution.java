package test;

import java.util.*;

/**
 * ClassName: test.Solution
 * Package: PACKAGE_NAME
 * Description:
 *
 * @Author jieHFUT
 * @Create 2025/8/6 3:30
 * @Version 1.0
 */
class Solution {
    public static void main(String[] args) {

        HashMap

        // System.out.println(isMatch("aab", "c*a*b"));
        // System.out.println(maxArea(new int[]{2,3,4,5,18,17,6}));
        // jisuan(21);
//        List<String> strings = letterCombinations("23");
//        for (String s : strings) {
//            System.out.println(s);
//        }
//        mergeKLists1(new ListNode[]{
//                new ListNode(1, new ListNode(4, new ListNode(5, null))),
//                new ListNode(1, new ListNode(3, new ListNode(4, null))),
//                new ListNode(2, new ListNode(6, null))
//        });

//        ListNode ret =  reverseKGroup(new ListNode(1,
//                                            new ListNode(2,
//                                                    new ListNode(3,
//                                                            new ListNode(4,
//                                                                    new ListNode(5, null))))), 3);
//        int i = removeElement(new int[]{2}, 3);
//        System.out.println(i);

//        int[] next = getNext("abcdadca");
//        System.out.println(Arrays.toString(next));

//        int[] next = getNext("abaababab");
//        System.out.println(Arrays.toString(next));
//
//        int index = strStr("mississippi", "issip");
//        System.out.println(index);

//        System.out.println(isMatchNew("aab", "c*a*b"));
//        List<Integer> list = new ArrayList<>();
//        list.add(4);
//        list.add(2);
//        list.add(9);
//        Collections.sort(list);
//        System.out.println(list);

//        System.out.println(threeSumClosest(new int[]{0, 0, 0}, 1));

//        List<List<Integer>> lists = fourSum(new int[]{2, 2, 2, 2, 2}, 8);
//        System.out.println(lists);
//        List<String> strings = generateParenthesis(2);
//        System.out.println(strings);

//        findSubstring("barfoofoobarthefoobarman", new String[]{"bar","foo","the"});

//        System.out.println(search(new int[]{4, 5, 6, 7, 0, 1, 2}, 3));

//        System.out.println(searchInsert(new int[]{3,5,7,9,10}, 8));

//        HashSet<Integer> set = new HashSet<>();

//        char[][] chars =
//                new char[][]{{'.','.','.','.','.','7','4','8','6'},
//                             {'8','4','7','.','6','2','.','9','3'},
//                             {'.','.','3','4','8','1','2','.','7'},
//                             {'2','5','8','3','.','4','.','.','9'},
//                             {'1','7','.','.','5','.','.','2','4'},
//                             {'6','.','4','1','2','9','5','.','.'},
//                             {'4','.','.','7','1','3','.','6','2'},
//                             {'3','2','1','6','.','.','7','.','5'},
//                             {'7','.','6','.','4','5','8','3','1'}};
//        char[][] charss =
//                new char[][]{{'5', '3', '.', '.', '7', '.', '.', '.', '.'},
//                             {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
//                             {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
//                             {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
//                             {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
//                             {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
//                             {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
//                             {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
//                             {'.', '.', '.', '.', '8', '.', '.', '7', '9'}};
//
//        char[][] charsss =
//                new char[][]{{'5', '3', '4', '6', '7', '8', '9', '1', '2'},
//                             {'6', '7', '2', '1', '9', '5', '3', '4', '8'},
//                             {'.', '9', '8', '.', '.', '2', '5', '6', '.'},
//                             {'8', '5', '9', '7', '6', '.', '.', '.', '3'},
//                             {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
//                             {'7', '1', '.', '9', '2', '4', '.', '.', '6'},
//                             {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
//                             {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
//                             {'3', '4', '.', '2', '8', '.', '.', '7', '9'}};
//
//
//
//        char[][] charssss =
//                new char[][]{{'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                             {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                             {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                             {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                             {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                             {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                             {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                             {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                             {'.', '.', '.', '.', '.', '.', '.', '.', '.'}};
//
//        long start = System.currentTimeMillis();
//        solveSudoku(charss);
//        long end = System.currentTimeMillis();
//        System.out.println(end - start);
//
//        for (char[] row : charss) {
//            System.out.println(Arrays.toString(row));
//        }
//
//        System.out.println(isConflict(new char[][]{{'0', '1', '2', '3', '4', '5', '6', '7', '8'},
//                {'1', '.', '.', '.', '.', '.', '.', '.', '.'},
//                {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                {'.', '.', '.', '.', '.', '.', '.', '.', '.'},
//                {'.', '.', '.', '.', '.', '.', '.', '.', '.'}}, 1, 0));


//        System.out.println(getRLE("11121"));

//        List<List<Integer>> lists1 = combinationSum(new int[]{1, 2, 3, 6, 7}, 24);
//        List<List<Integer>> lists = combinationSum(new int[]{2, 3, 6, 7}, 7);
//        lists.forEach(System.out::println);

//        List<List<Integer>> lists = combinationSum2(new int[]{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
//                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
//                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, 30);
//        for (List<Integer> list : lists) {
//            System.out.println(list);
//        }

//        HashSet<Integer> set = new HashSet<>();
//        System.out.println(multiply("2", "3"));

//        StringBuilder str = new StringBuilder("eiwohfgiqowugf");
//        str.deleteCharAt("eiwohfgiqowugf".length()-2);
//        str.insert("eiwohfgiqowugf".length()-2, 'w');
//        str.insert(0, 'f');
//        System.out.println(str.toString());

//        System.out.println(multiply("9133", "0"));

//        System.out.println(jump(new int[]{5, 6, 4, 4, 6, 9, 4, 4, 7, 4, 4, 8, 2, 6,
//                8, 1, 5, 9, 6, 5, 2, 7, 9, 7, 9, 6, 9, 4, 1, 6, 8, 8, 4, 4, 2, 0, 3, 8, 5}));

//        System.out.println(jump(new int[]{3,2,0,2,2,1,5}));
//        int[] nums = new int[]{1,2,3,4,5,6};
//        Arrays.asList(nums);
//        int[][] matrix = new int[][]{{1,2,3},{4,5,6},{7,8,9}};
//        rotate(matrix);
//        for (int[] row : matrix) {
//            System.out.println(Arrays.toString(row));
//        }

    }


    /////////////////////////48///////////////////////////////////////////////////////////
    public static void rotate(int[][] matrix) {
        // 思路：先将二维矩阵的行列进行交换，然后左右交换
        for (int i = 0; i < matrix.length; i++) {
            for (int j = i + 1; j < matrix.length; j++) {
                swap(matrix, i, j);
            }
        }
        // 然后左右交换
        int l = 0;
        int r = matrix.length - 1;
        while (l < r) {
            // 交换这两列
            swapcol(matrix, l, r);
            l++;
            r--;
        }
    }

    // 交换两个位置的数字
    public static void swap(int[][] matrix, int i, int j) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[j][i];
        matrix[j][i] = temp;
    }

    public static void swapcol(int[][] matrix, int l, int r) {
        for (int i = 0; i < matrix.length; i++) {
            int temp = matrix[i][l];
            matrix[i][l] = matrix[i][r];
            matrix[i][r] = temp;
        }
    }
    ////////////////////////////////////////46//////////////////////////////////////////////////////////////////////////
    public List<List<Integer>> permute(int[] nums) {
        // 思路：使用回溯
        List<Integer> origin = new ArrayList<>();
        for (int num : nums) {
            origin.add(num);
        }
        permutation(new ArrayList<>(), origin);
        return ret46;
    }

    List<List<Integer>> ret46 = new ArrayList<>();

    public void permutation(List<Integer> every, List<Integer> rest) {
        // 如果剩余的集合中没有元素，就添加
        if (rest.size() == 0) {
            ret46.add(every);
            return;
        }

        // 如果不是空的，就将其剩余的元素全部遍历一遍添加进去
        for (int i = 0; i < rest.size(); i++) {
            List<Integer> tevery = new ArrayList<>();
            tevery.addAll(every);

            List<Integer> trest = new ArrayList<>();
            trest.addAll(rest);

            // 将下标 i 位置的元素取出来放到 every 中
            tevery.add(trest.remove(i));

            permutation(tevery, trest);
        }
    }
    ///////////////////////////////////////////////45///////////////////////////////////////////////////////////////////
    public static int jump(int[] nums) {
        // 思路二：采用递归
        return minStep(nums, 0);
    }

    // 返回这个下标到终点的最短距离
    public static int minStep(int[] nums, int index) {
        if (index == nums.length - 1) {
            // 找到一个结果
            return 0;
        }

        int key = nums[index];
        int thisMin = Integer.MAX_VALUE - 8;

        for (int i = 1; i <= key; i++) {
            // 这个位置遍历一遍，返回 index + i 位置到终点的最小步数
            if (index + i < nums.length) {
                int nextStep = minStep(nums, index + i);
                if (nextStep < thisMin) {
                    thisMin = nextStep;
                }
            }
        }
        // 也就是说是从这个位置直接跳到 i 位置的步数最小
        return 1 + thisMin;
    }


    public static int jump1(int[] nums) {
        // 思路一：采用回溯法，缺点是某一个数字跳过了一遍，还会有不同的前缀也跳过它，重复太多
        minStep(nums, 0, nums.length - 1, 0);
        return minStep;
    }

    static int minStep = Integer.MAX_VALUE;
    /**
     * @param nums 传递的原始数组
     * @param step 目前到这个下标已经跳跃的次数
     * @param restLength 还剩下的距离
     * @param index 目前处于的下标
     *
     */
    public static void minStep(int[] nums, int step, int restLength, int index) {
        // 如果还剩下的距离是 0，就说明刚好到达终点，记录一下
        if (restLength == 0) {
            if (step < minStep) minStep = step;
            return;
        }
        // 如果剩下的距离小于 0，就不用再跳了
        if (restLength < 0) return;

        // 剩下的距离大于 0，遍历目前位置大小的步数（从 1 开始）
        int key = nums[index];

        for (int i = 1; i <= key; i++) {
            if (i > restLength) {
                break;
            } else {
                if (index + i < nums.length) {
                    minStep(nums, step + 1, restLength - i, index + i);
                }
            }
        }
    }

    /////////////////////////////////43/////////////////////////////////////////////////////////////////////////////////
    public static String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";

        // 思路：num1 依次去和 num2 的一位计算，从后往前（各位不变，十位先在尾部 append 一个0...）
        StringBuilder str = new StringBuilder();

        for (int i = num2.length() - 1; i >= 0; i--) {
            // 获取 num2 下标为 i 位置的数据
            int num = num2.charAt(i) - '0';

            StringBuilder every = new StringBuilder();
            every.append(num1);
            // 在竖式之前需要给 str 后面补充 num2.length() - i - 1 个 0
            for (int j = 0; j < num2.length() - i - 1; j++) {
                every.append('0');
            }
            // 开始进行竖式计算
            // 表示计算 K 下标的时候的进位
            int isCarry = 0;
            for (int k = every.length() - 1; k >= 0; k--) {

                int key = every.charAt(k) - '0';
                int multiply = key * num + isCarry;

                // 设置下一个进位（10-99）
                isCarry = multiply / 10;

                // 当前位置数据变为 multiply 的个位数
                every.deleteCharAt(k);
                every.insert(k, multiply % 10);
            }

            // 判断最后一位是否需要进位
            if (isCarry != 0) {
                every.insert(0, isCarry);
            }


            // 在这里对其使用加法来计算
            int isCarry2 = 0;
            int lens = str.length() - 1;
            int lene = every.length() - 1;
            StringBuilder record = new StringBuilder();

            while (lens >= 0 && lene >= 0) {
                int add = (str.charAt(lens) - '0') + (every.charAt(lene) - '0') + isCarry2;
                // 新的进位
                isCarry2 = add / 10;
                record.insert(0, add % 10);
                lene--;
                lens--;
            }
            if (lens == -1) {
                while (lene >= 0) {
                    int single = every.charAt(lene) - '0' + isCarry2;
                    isCarry2 = single / 10;
                    record.insert(0, single % 10);
                    lene--;
                }
            }
            if (lene == -1) {
                while (lens >= 0) {
                    int single = str.charAt(lens) - '0' + isCarry2;
                    isCarry2 = single / 10;
                    record.insert(0, isCarry2 % 10);
                }
            }
            if (isCarry2 != 0) {
                record.insert(0, 1);
            }

            str = record;
        }
        return str.toString();
    }

    public static String multiply1(String num1, String num2) {
        // 思路：采用竖式计算 123 * 456

        // 计算竖式中有几行
        int record = 1;
        int total = 0;
        for (int i = num1.length() - 1; i >= 0; i--) {


            // count 是用来记录位数的
            int count = 1;
            int sum = 0;
            for (int j = num2.length() - 1; j >= 0; j--) {
                sum += (num2.charAt(j) - '0') * (num1.charAt(i) - '0') * count;
                count *= 10;
            }
            // 得到了竖式计算的一行
            total += sum * record;
            record *= 10;
        }

        return record + "";
    }
    ////////////////////////////////////////////////40//////////////////////////////////////////////////////////////////
    public static List<List<Integer>> combinationSum2(int[] candidates, int target) {
        // 每个数字只能使用一次
        ret40 = new ArrayList<>();
        Arrays.sort(candidates);
        combination40(candidates, candidates.length - 1, target, new ArrayList<>());

        // 还需要对 ret40 进行去重
        HashSet<List<Integer>> set = new HashSet<>();
        for(List<Integer> every : ret40) {
            set.add(every);
        }
        return new ArrayList<>(set);
    }

    static List<List<Integer>> ret40 = new ArrayList<>();
    /**
     *
     * @param candidates 原始数组
     * @param target 从大往小，已经去掉了多少大数，还剩下的 target
     * @param index 目前该讨论的数字，后面比他大的数字都遍历过了
     * @param lists 后面后面比他大的数字遍历的集合
     */
    public static void combination40(int[] candidates, int index, int target, List<Integer> lists) {
        if (target == 0) {
            // 找到一组有效的序列
            ret40.add(lists);
            return;
        }

        if (index == -1) return;

        // 分类：candidates[index] 的有无分为两类
        List<Integer> toNext = new ArrayList<>();

        if (candidates[index] > target) {
            // 不能有这个数字

            combination40(candidates, index - 1, target, lists);
        } else {
            // 可能有这个数字 => 两种情况
            toNext.add(candidates[index]);
            toNext.addAll(lists);
            combination40(candidates, index - 1, target - candidates[index], toNext);

            combination40(candidates, index - 1, target, lists);
        }

    }
    ////////////////////////////////////////////////39//////////////////////////////////////////////////////////////////
    public static List<List<Integer>> combinationSum(int[] candidates, int target) {
        // 思路：先将数组进行排序后，先以最大的数据来看
        // 集合 = 去除 n 个最大值（不带最大值的集合）
        // 1 2 3 6 7 => 24 集合 A
        // 1 2 3 6 => 17 集合 B （带一个7）
        // 1 2 3 6 => 10 集合 C （带二个7）
        // 1 2 3 6 => 3 集合 D （带三个7）
        // 集合A = B + C + D
        ret39 = new ArrayList<>();
        Arrays.sort(candidates);
        combination(candidates, target, candidates.length - 1, new ArrayList<>());
        return ret39;
    }

    // 传入的是有序的数组(最初的下标是 len - 1)
    // 使用数组的前 index 下标的元素组成和为 target 的集合
    static List<List<Integer>> ret39 = new ArrayList<>();
    /**
     *
     * @param candidates 原始数组
     * @param target 从大往小，已经去掉了多少大数，还剩下的 target
     * @param index 目前该讨论的数字，后面比他大的数字都遍历过了
     * @param list 后面后面比他大的数字遍历的集合
     */
    public static void combination(int[] candidates, int target, int index, List<Integer> list) {
        if (target == 0) {
            // 找到了一组合法的序列
            ret39.add(list);
            return;
        }
        // 如果遍历完数组还没有找到一组合理的序列，就不要往下找了
        if (index == -1) return;

        // 往下一个元素，也就是将 target - i * candidates[index]
        for(int i = 0; i <= target / candidates[index]; i++) {
            List<Integer> toNext = new ArrayList<>();
            // 放置 i 个 candidates[index] 元素，在其前面
            for (int j = 0; j < i; j++) {
                toNext.add(candidates[index]);
            }
            toNext.addAll(list);

            // 这个时候集合中新添加了 i 个 candidates[index]
            combination(candidates, target - i * candidates[index], index - 1, toNext);
        }
    }
    ///////////////////////////////////////////////38/////////////////////////////////////////////////////////////////////
    public static String countAndSay(int n) {
        // 思路：
        StringBuilder str = new StringBuilder();
        String key = "1";
        for (int k = 1; k < n; k++) {
            key = getRLE(key);
        }
        return key;
    }

    // 根据字符串 s 获取其行程长度编码
    public static String getRLE(String s) {
        StringBuilder str = new StringBuilder();

        for (int i = 0; i < s.length(); i++) {
            // 用来记录某个数字有多少个
            int count = 1;
            // 当某一个数字等于前一个的时候，就记录一下，然后 i++
            while (i + 1 < s.length() && s.charAt(i) == s.charAt(i + 1)) {
                i++;
                count++;
            }
            // 这个地方有 count 个 s.charAt(i)
            str.append(count + "");
            str.append(s.charAt(i));
        }

        return str.toString();
    }


    /////////////////////////////////////////////////37///////////////////////////////////////////////////////////////////
    public static void solveSudoku(char[][] board) {
        // 思路：使用回溯法来进行解决，和八皇后问题差不多
        addNum(board, 0, 0);

    }

    // 在第 i 行 j 列添加了一个数字是否成立
    public static boolean isConflict(char[][] board, int i, int j) {
        // 判断行是否冲突
        for (int k = 0; k < 9; k++) {
            if (k != j && board[i][k] == board[i][j]) {
                return true;
            }
        }

        // 判断列是否冲突
        for (int k = 0; k < 9; k++) {
            if (k != i && board[k][j] == board[i][j]) {
                return true;
            }
        }

        // 判断方格是否冲突（向左向上找到整除 3 的数字，向右向下找到整除 3 的前一个数字）
        int col = i;
        int row = j;
        while (col % 3 != 0) col--;
        while (row % 3 != 0) row--;

        for (int k = col; k < col + 3; k++) {
            for (int l = row; l < row + 3; l++) {
                if (k != i && l != j && board[k][l] == board[i][j]) {
                    return true;
                }
            }
        }

        return false;
    }

    static boolean isOver = false;

    // 在 i 行 j 列添加一个数字（思路：先看行从最不重复的最小值开始，然后看列和块是否满足，不满足看行的下一个）
    public static void addNum(char[][] board, int i, int j) {
        // 判断回溯的结束条件
        if (i == 9) {
            // 前面的 9x9 的数字已经放置完毕
            isOver = true;
            return;
        }
        // 如果整个位置已经存在数字了，就直接放置下一个数字
        if (board[i][j] == '.') {
            // 对这个位置开始放 0-9 的数字，放置后开始进行判断
            for (int key = 0; key < 9; key++) {
                // 将这个位置置为 key
                board[i][j] = (char) (key + '1');

                boolean isConflict = isConflict(board, i, j);
                if (!isConflict) {
                    // 如果不冲突就放置下一个数字（先放置行，每一行结束了再下一行）
                    if (j < 8) {
                        addNum(board, i, j + 1);
                    } else if (j == 8) {
                        addNum(board, i + 1, 0);
                    }
                    // 判断这是返回的时候经过，还是重新选取数值的时候经过
                    if (isOver) {
                        return;
                    }
                } else {
                    // 放置这个数字产生冲突，将其重新设置为 '.'，这个 i j 位置就去放置下一个数字 key
                    board[i][j] = '.';
                }
            }

        } else {
            // 这个位置本来就有数字，直接放下一个位置
            if (j < 8) {
                addNum(board, i, j + 1);
            } else if (j == 8) {
                addNum(board, i + 1, 0);
            }
        }

    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public static boolean isValidSudoku(char[][] board) {
        // 思路：将每一行，每一列，每一宫内数字拿出来组成长度为9的数组，去除 '.' 后使用 hashset 进行判断是否重复

        // 1.每一行
        for (char[] chars : board) {
            HashSet<Character> set = new  HashSet<>();
            for(char ch : chars) {
                if (ch != '.') {
                    if (set.contains(ch) == true) {
                        return false;
                    } else {
                        set.add(ch);
                    }
                }
            }
        }

        // 2.每一列
        for (int i = 0; i < board[i].length; i++) {
            // 表示第 i 列
            HashSet<Character> set = new HashSet<>();
            for (int j = 0; j < board.length; j++) {
                if (board[j][i] != '.') {
                    if (set.contains(board[j][i]) == true) {
                        return false;
                    } else {
                        set.add(board[j][i]);
                    }
                }
            }
        }

        // 3. i = 0, 3, 6
        for (int i = 0; i < 9; i += 3) {
            // j = 0, 3, 6
            for (int j = 0; j < 9; j += 3) {
                // 每一个方格
                HashSet<Character> set = new HashSet<>();
                // i 行 j 列 开始找 9 个数字
                for (int k = i; k < i + 3; k++) {
                    for(int l = j; l < j + 3; l++) {
                        if (board[k][l] != '.') {
                            if (set.contains(board[k][l]) == true) {
                                return false;
                            } else {
                                set.add(board[k][l]);
                            }
                        }
                    }
                }
            }
        }

        return true;
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public static int searchInsert(int[] nums, int target) {
        // 使用二分法：1.找到 target 返回下标
        //            2.找到 left 比 right 小 1 的位置开始判断
        int len = nums.length;

        if (len == 0) return 0;
        if (len == 1 && nums[0] == target) return 0;
        if (len == 1 && nums[0] < target) return 1;
        if (len == 1 && nums[0] > target) return 0;

        int l = 0, r = len - 1;
        if (target <= nums[0]) return 0;
        if (target == nums[len - 1]) return len - 1;
        if (target > nums[len - 1]) return len;

        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return mid;
            }


            if (nums[mid] < target) {
                if (r - 1 == mid && target < nums[r]) {
                    return r;
                } else if(r - 1 == mid && target > nums[r]) {
                    return r + 1;
                }
                // 移动之前还需要判断一下
                if(nums[mid + 1] > target) {
                    return mid + 1;
                }

                l = mid + 1;
            } else {
                if (l + 1 == mid && target < nums[l]) {
                    return l;
                } else if(l + 1 == mid && target > nums[l]) {
                    return mid;
                }
                // 移动之前还需要判断一下
                if(nums[mid - 1] < target) {
                    return mid;
                }

                r = mid - 1;
            }
        }
        return -1;
    }

    public static int search(int[] nums, int target) {

        // 思路：判断 target 在有序的一边还是无序的一边，然后使用二分法进行查找
        int index = getIndex(nums, target, 0, nums.length - 1);
        return index;


    }

    public static int getIndex(int[] nums, int target, int left, int right) {
        int ret = -1;
        int mid = (left + right) / 2;

        if (nums[mid] == target) {
            // 寻找到目标值
            return mid;
        }

        // 如果 left == right
        if (left == right) {
            return ret;
        }

        // 此时 left 与 right 之间的数据已经是有序的了
        if (nums[right] >= nums[left]) {
            if (target > nums[right] || target < nums[left]) {
                return ret;
            }

            if (nums[mid] > target) {
                right = mid - 1;
                ret = getIndex(nums, target, left, right);
            } else {
                left = mid + 1;
                ret = getIndex(nums, target, left, right);
            }

        }

        if (ret != -1) return ret;

        // 传入的是无序的一边
        if (nums[mid] > nums[left]) {
            // 左边有序，右边无序
            if (target > nums[left]) {
                right = mid - 1;
                ret = getIndex(nums, target, left, right);
            } else {
                left = mid + 1;
                ret = getIndex(nums, target, left, right);
            }

        } else {
            // 左边无序，右边有序
            if (target > nums[mid] && target <= nums[right]) {
                left = mid + 1;
                ret = getIndex(nums, target, left, right);
            } else {
                right = mid - 1;
                ret = getIndex(nums, target, left, right);
            }
        }

        return ret;

    }

    public static List<Integer> findSubstring(String s, String[] words) {
        // 思路：先找 words 可以组成的所有字符串集合，然后使用 KMP 算法进行验证
        List<String> rest = new  ArrayList();
        for (String str : words) {
            rest.add(str);
        }

        // 1.使用回溯来寻找所有的字符串集合
        List<String> all = new ArrayList<>();
        findAll(rest, new StringBuilder(), all);
        System.out.println("没有进行去重的：" + all);

        // 对 all 集合进行去重
        HashSet<String> set = new HashSet<>(all);
        List<String> res = new ArrayList<>(set);
        System.out.println("已经进行去重的：" + res);
        // 对 all 集合采用 KMP 算法

        return null;
    }

    /**
     * rest：目前数组集合中还剩下的字符串
     * str：目前已经使用的字符串组成的数组
     * list：用来记录全部字符串都连接的一个结果
     */
    public static void findAll(List<String> rest, StringBuilder str, List<String> list) {
        if (rest.isEmpty()) {
            // 找到一个结果
            list.add(str.toString());
            return;
        }

        // rest 内还有元素，遍历依次添加
        for (int i = 0; i < rest.size(); i++) {
            StringBuilder builder = new StringBuilder(str);
            builder.append(rest.get(i));
            List<String> every = new ArrayList(rest);
            every.remove(i);
            findAll(every, builder, list);
        }
    }

    public static List<String> generateParenthesis(int n) {
        List<String> ret = new ArrayList();

        if (n <= 0) return ret;
        parenthesis1(n, n, ret, new StringBuilder());
        return ret;
    }

    public static void parenthesis1(int left, int right, List<String> ret, StringBuilder s) {
        // 如果这个时候左右括号的数量都为零
        if (left == 0 && right == 0) {
            ret.add(s.toString());
            return;
        }

        // 如果左右括号数量一样了，下一个只能使用左括号
        if (left == right) {
            StringBuilder str = new StringBuilder(s);
            parenthesis1(left - 1, right, ret, str.append('('));
        } else if (left < right) {
            // 否则既可以使用左括号，也可以使用右括号
            if (left > 0) {
                StringBuilder str = new StringBuilder(s);
                parenthesis1(left - 1, right, ret, str.append('('));
            }
            StringBuilder str = new StringBuilder(s);
            parenthesis1(left, right - 1, ret, str.append(')'));
        }


    }
    public static void parenthesis(int left, int right, List<String> ret, String s) {
        // 如果这个时候左右括号的数量都为零
        if (left == 0 && right == 0) {
            ret.add(s.toString());
            return;
        }

        // 如果左右括号数量一样了，下一个只能使用左括号
        if (left == right) {
            parenthesis(left - 1, right, ret, s+"(");
        } else if (left < right){
            // 否则既可以使用左括号，也可以使用右括号
            if (left > 0) {
                parenthesis(left - 1, right, ret, s+"(");
            }
            parenthesis(left, right - 1, ret, s+")");
        }


    }


    public static List<String> generateParenthesis1(int n) {
        // 思路一：暴力法，列举全部可能性，判断是否成立（有两种字符）
        List<String> save = new ArrayList<>();
        StringBuilder str = new StringBuilder();
        getKinds(n, n, str, save);

        // 检查每一个 string 是否符合条件
        List<String> ret = new ArrayList();
        for (String every : save) {
            if (isPass(every)) {
                ret.add(every);
            }
        }
        return ret;
    }

    /**
     * left 还剩下多少个 '('
     * right 还剩下多少个 ')'
     * str 目前的排列字符串
     * save 用来存储所有可能的结果
     */
    public static void getKinds(int left, int right, StringBuilder str, List<String> save) {


        if (left == 0 && right == 0) {
            save.add(str.toString());
        }

        // 尝试放左括号
        if (left > 0) {
            StringBuilder builder = new StringBuilder(str);
            getKinds(left-1, right, builder.append('('), save);
        }

        // 尝试放右括号
        if (right > 0) {
            StringBuilder builder = new StringBuilder(str);
            getKinds(left, right - 1, builder.append(')'), save);
        }

    }

    // 判断一个字符串是否是成立的括号组合
    public static boolean isPass(String str) {
        // 使用一个栈，如果是左括号就放进去，如果是右括号就要 peek 一个看看，成对就出
        // 不成对就 false
        Stack<Character> stack = new Stack();

        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '(') {
                stack.push(str.charAt(i));
            } else {
                if (stack.isEmpty() || stack.pop() != '(') {
                    return false;
                }
            }
        }
        return true;
    }


    public static List<List<Integer>> fourSum(int[] nums, int target) {
        // 思路：三个的基础上再加一层循环吗？
        List<List<Integer>> ret = new ArrayList<List<Integer>>();

        // 先进行排序
        Arrays.sort(nums);

        for (int first = 0; first < nums.length; first++) {
            // 如果遇到重复的就进行跳过
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }

            // 进行第二层循环
            for (int second = first + 1; second < nums.length; second++) {
                if (second > 1 && nums[second] == nums[second - 1]) {
                    continue;
                }

                int left = second + 1;
                int right = nums.length - 1;
                int key = target - nums[first] - nums[second];

                while (left < right) {
                    if (nums[left] + nums[right] == key) {
                        ret.add(Arrays.asList(nums[first], nums[second], nums[left], nums[right]));
                        left++;
                        right--;
                        while (left < right && nums[left] == nums[left - 1]) left++;
                        while (left < right && nums[right] == nums[right + 1]) right--;
                    } else if (nums[left] + nums[right] < key) {
                        left++;
                        while (left < right && nums[left] == nums[left - 1]) left++;
                    } else {
                        right--;
                        while (left < right && nums[right] == nums[right + 1]) right--;
                    }
                }
            }
        }
        return ret;
    }

    public static int threeSumClosest(int[] nums, int target) {
        // 思路一：先进行排序，然后进行遍历
        // 先固定一个数字 nums[i], 然后前后指针
        // 每遍历一遍都记录最小差
        Arrays.sort(nums);

        int ret = Integer.MAX_VALUE;

        for (int first = 0; first < nums.length; first++) {
            // 判断是否重复，如果重复就前进
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // 剩下两个数字相加距离 key 最近
            int key = target - nums[first];
            int left = first + 1;
            int right = nums.length - 1;
            int sum = 0;

            while (left < right) {

                sum = nums[left] + nums[right] - key;

                if(Math.abs(sum) < ret) ret = Math.abs(sum);

                if (sum == 0) {
                    return target;
                } else if (sum < 0) {
                    left++;
                    // 如果移动的数字和前面一样，就再次移动一下
                    if (left < right && nums[left] == nums[left - 1]) left++;
                } else {
                    right--;
                    // 如果移动的数字和前面一样，就再次移动一下
                    if (left < right && nums[right] == nums[right+1]) right--;
                }
            }

        }
        return ret;

    }


    public static List<List<Integer>> threeSum(int[] nums) {

        List<List<Integer>> ret = new ArrayList<>();

        // 返回所有和为 0 且不重复的三元组
        // 考虑到第一题的求两数之和 nums[i] + nums[j] = -nums[k]
        int[] reverse = new int[nums.length];
        for(int i = 0; i < nums.length; i++) {
            reverse[i] = -nums[i];
        }

        // 遍历 reverse
        for (int i = 0; i < reverse.length; i++) {
            int tarket = reverse[i];
            int index = i;

            // 然后对 nums[i] 和 nums[j] 进行下手
            HashMap<Integer, Integer> map = new HashMap<>();
            // 遍历 nums
            for (int j = 0; j < nums.length && j != index; j++) {

                if (map.containsKey(tarket - nums[j])) {
                    // 找到了（key存放 nums[]，value存放下标）
                    List<Integer> group = new ArrayList();
                    group.add(index);
                    group.add(j);
                    group.add(map.get(tarket - nums[j]));

                    if (!isHave(ret, group)) {
                        ret.add(group);
                    }
                }
                // 没有找到
                map.put(nums[j], j);
            }
        }
        return ret;
    }

    public static boolean isHave(List<List<Integer>> origin, List<Integer> newAdd) {
        // 遍历
        for (List<Integer> toCompare : origin) {
            if (new HashSet<>(toCompare).equals(new HashSet<>(newAdd))) {
                return true;
            }
        }
        return false;
    }
    public static boolean isMatchNew(String s, String p) {
        // 思路三，使用队列，从前面开始遍历 p，然后每次遍历的时候需要 peek 一下
        Queue<Character> queue = new LinkedList();

        for (int i = 0; i < p.length(); i++) {
            queue.offer(p.charAt(i));
        }
        // 保存 s 的下标
        int index = 0;

        while (!queue.isEmpty()) {

            char ch = queue.poll();

            if (!queue.isEmpty() && queue.peek() == '*') {
                // 有下一个元素且为 *
                if (ch == '.') {
                    // .* 结构
                    return true;
                } else {
                    // 普通的 c* 结构
                    queue.poll();
                    // 记录 p 的后面还有多少个 ch 元素
                    int count = 0;
                    while (!queue.isEmpty() && queue.peek() == ch) {
                        queue.poll();
                        count++;
                    }
                    // 也就是 s 最少要有 count 个 ch 元素
                    while (count > 0) {
                        if (index == s.length()) {
                            return false;
                        } else if (s.charAt(index) != ch) {
                            return false;
                        } else {
                            index--;
                            count--;
                        }
                    }
                    // 让 s 走到没有 ch 的地方
                    while (index < s.length() && s.charAt(index) == ch) {
                        index++;
                    }

                    // 判断结束标志
                    if (index == s.length() && queue.isEmpty()) {
                        return true;
                    } else if (index == s.length() || queue.isEmpty()) {
                        return false;
                    }
                    // 否则遍历继续
                }
            } else {
                // 不是 * 结构
                if (ch == '.') {

                } else {
                    // 普通字符
                    if (s.charAt(index) != ch) {
                        return false;
                    }
                }
                index++;
                // 判断结束标志
                if (index == s.length() && queue.isEmpty()) {
                    return true;
                } else if (index == s.length() || queue.isEmpty()) {
                    return false;
                }
                // 否则遍历继续
            }
        }
        return false;
    }


    public static int strStr(String haystack, String needle) {
        // 手撕 KMP 算法
        int[] next = getNext(needle);
        // 每次遇到匹配不成功的需要前进的程度为：前面已经匹配的数量 - 其匹配值
        for (int i = 0; i < haystack.length(); ) {
            int j = 0;
            for (j = 0; j < needle.length(); j++) {

                // 如果越界了但是 needle 没有到尽头
                if (i + j == haystack.length() && j != needle.length()) {
                    return -1;
                }

                if (haystack.charAt(i) != needle.charAt(0)) {
                    i++;
                    break;
                }
                if (i+j < haystack.length() && haystack.charAt(i+j) != needle.charAt(j)) {
                    i += j-next[j-1];
                    break;
                }
            }
            if (j == needle.length()) {
                // 表示这一次完全匹配成功
                return i;
            }
        }
        return -1;
    }

    // 获取字符串 needle 的 next[] 数组
    public static int[] getNext(String needle) {
        //
        int[] ret = new int[needle.length()];
        int index = 0;

        for (int i = 0; i < needle.length(); i++) {
            if (i == 0) {
                ret[i] = 0;
            } else {
                if (needle.charAt(i) == needle.charAt(index)) {
                    ret[i] = ret[i-1] + 1;
                    index++;
                } else if(needle.charAt(i) == needle.charAt(0)) {
                    ret[i] = 1;
                    index = 1;
                }
            }
        }
        return ret;
    }

    public static int removeElement(int[] nums, int val) {
        // 思路：前后指针，前面找 val，后面找非 val，进行交换
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        int left = 0;
        int right = len - 1;


        while(left < right) {

            while(left < len && nums[left] != val) {
                left++;
            }
            if (left == len) {
                return len;
            }
            while(right > -1 && nums[right] == val) {
                right--;
            }
            if (left > right) {
                break;
            }
            // 进行交换
            swap(nums, left, right);
        }
        // 交换完成了

        int count = 0;
        int index = len - 1;
        int record = nums[index];
        while(index > -1 && nums[index] == record) {
            count++;
            index--;
        }
        return len - count;

    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null || k == 1) return head;
        // 思路：持续翻转，每次翻转 K 个以后，就以最后一个节点为新的开始节点再翻转 K 个

        // 先创建一个指针先走 K-1 个，如果走不到就直接返回，走到了就与遍历同时走，
        // 如果这一组翻转完成期间，先走的指针.next 指到空的了就不要再继续了
        ListNode advance = head;
        for (int i = 1; i < k; i++) {
            advance = advance.next;
            if (advance == null) {
                return head;
            }
        }

        ListNode newHead = new ListNode();
        ListNode ret = newHead;

        int count = 0; // 记录翻转了几个
        boolean flag = true; // 记录下一轮 K 个要不要翻转
        while (flag) {

            for (int j = 0; j < k; j++) {
                // 应该再翻转之前进行判断
                if (advance.next == null) {
                    flag = false;
                } else {
                    advance = advance.next;
                }

                // 一轮翻转 K 个
                ListNode temp = head.next;
                head.next = newHead.next;
                newHead.next = head;
                head = temp;
            }
            // 移动 newHead 到最后一个节点再来一遍
            for (int m = 0; m < k; m++) {
                newHead = newHead.next;
            }
        }

        // 到这里还有最后一个不足 K 的需要添加到末尾
        newHead.next = head;

        return ret.next;
    }

    public static ListNode mergeKLists1(ListNode[] lists) {
        // 使用小顶堆来实现
        Queue<ListNode> queue = new PriorityQueue<>(new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                return o1.val - o2.val;
            }
        });

        // 把各个链表的第一个元素，也就是头节点放进去了，这些头节点组成了一个小顶堆
        for (int i = 0; i < lists.length; i++) {
            if (lists[i] != null) {
                queue.add(lists[i]);
            }
        }

        ListNode head = new ListNode();
        ListNode r = head; // 记录
        while(!queue.isEmpty()){
            // 将最小的出优先级队列
            ListNode temp = queue.poll();
            // 如果这个最小节点还有后续节点，就将其加入最小堆
            if(temp.next != null)
                queue.offer(temp.next);
            r.next = temp;
            r = r.next;
            r.next = null;
        }
        return head.next;


    }

    public static ListNode mergeKLists(ListNode[] lists) {
        // 取 n 个指针，然后遍历到头的令其值为 Integer.MAX_VALUE，如果某一次最小值为 Integer.MAX_VALUE
        ListNode[] point = new ListNode[lists.length];
        // 赋值所有的指针
        for (int i = 0; i < lists.length; i++) {
            point[i] = lists[i];
        }
        ListNode ret = new ListNode();
        while (true) {
            // 记录最小值的指针下标
            int index = -1;
            int minValue = Integer.MAX_VALUE;
            // 遍历各个指针，如果不是 null 就参与比较
            for (int j = 0; j < point.length; j++) {
                if (point[j] != null && point[j].val < minValue) {
                    minValue = point[j].val;
                    index = j;
                }
            }

            // 判断是否结束
            if (index == -1) {
                break;
            } else {
                // 进行返回集合的拼接和最小指针的移动
                ListNode minNext = point[index].next;
                point[index].next = ret.next;
                ret.next = point[index];
                point[index] = minNext;
            }
        }
        // 结束了，需要对集合 ret 进行反转
        return reverse(ret.next);
    }

    // 对单链表进行反转
    public static ListNode reverse(ListNode node) {
        // 思路：使用双指针
        if (node == null || node.next == null) return node;
        ListNode advance = node.next;
        ListNode after = node;
        after.next = null;

        while (advance != null) {
            // 记录下一个
            ListNode temp = advance.next;
            advance.next = after;
            after = advance;
            advance = temp;
        }
        return after;
    }

    static List<String> ret = new ArrayList();

    static HashMap<Integer, String[]> values = new HashMap(){
        {
            put(2, new String[]{"a","b","c"});
            put(3, new String[]{"d","e","f"});
            put(4, new String[]{"g","h","i"});
            put(5, new String[]{"j","k","l"});
            put(6, new String[]{"m","n","o"});
            put(7, new String[]{"p","q","r","s"});
            put(8, new String[]{"t","u","v"});
            put(9, new String[]{"w","x","y","z"});
        }
    };

    // 方法三（DFS-深度优先遍历）
    public static List<String> letterCombinations(String digits) {
        dfs(digits, new StringBuilder(), 0);
        return ret;
    }
    /**
     * 深度优先遍历：
     * String digits 原始字符串数字
     * StringBuilder sb
     * int index 遍历的第几个数字
     */
    public static void dfs(String digits, StringBuilder sb, int index) {
        if (digits == null || digits.length() == 0) {
            return;
        }
        if (index == digits.length()) {
            // 上一轮遍历到最后一个数字了
            ret.add(sb.toString());
            return;
        }
        String[] cur = values.get(digits.charAt(index) - '0');
        for (int i = 0; i < cur.length; i ++) {
            sb.append(cur[i]);
            dfs(digits, sb, index + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }

    public static List<String> letterCombinations2(String digits) {
        List<String> ret = new ArrayList();
        if (digits.length() == 0) return ret;

        HashMap<Integer, String[]> values = new HashMap();
        values.put(2, new String[]{"a","b","c"});
        values.put(3, new String[]{"d","e","f"});
        values.put(4, new String[]{"g","h","i"});
        values.put(5, new String[]{"j","k","l"});
        values.put(6, new String[]{"m","n","o"});
        values.put(7, new String[]{"p","q","r","s"});
        values.put(8, new String[]{"t","u","v"});
        values.put(9, new String[]{"w","x","y","z"});
        for (String str : values.get(digits.charAt(0) - '0')) {
            ret.add(str);
        }
        if (digits.length() == 1) return ret;

        // 在这里最少有一个数字
        // 记录目前要添加的是第几个数字的下标
        int index = 1;
        backtrack(ret, values, digits, index);
        return ret;
    }
    /**
     * List<String> prev 前面所有的数字组成的字符串集合
     * HashMap<Integer, String[]> values 数字与字符之间的对应关系
     * String digits 原始的字符串数字
     * int index 当前是第几个数字
     * 教训：只有回溯的终结条件可以开始直接返回，初始就成立的不能直接返回
     */
    public static void backtrack(List<String> prev, HashMap<Integer, String[]> values, String digits, int index) {
        if (index == digits.length()) {
            return;
        }
        // 添加了这个数字之后的集合
        List<String> nowList = new ArrayList();

        for (String prevStr : prev) {
            for (String nowStr : values.get(digits.charAt(index) - '0')) {
                nowList.add(prevStr + nowStr);
            }
        }
        backtrack (nowList, values, digits, index + 1);

        // 不能重新赋值，需要添加值
        prev.clear();
        for (String nowStr : nowList) {
            prev.add(nowStr);
        }

    }

    public static List<String> letterCombinations1(String digits) {
        // 返回的集合
        int len = digits.length();
        List<String> ret = new ArrayList();

        if (len == 0) return ret;

        HashMap<Integer, String[]> values = new HashMap();
        values.put(2, new String[]{"a","b","c"});
        values.put(3, new String[]{"d","e","f"});
        values.put(4, new String[]{"g","h","i"});
        values.put(5, new String[]{"j","k","l"});
        values.put(6, new String[]{"m","n","o"});
        values.put(7, new String[]{"p","q","r","s"});
        values.put(8, new String[]{"t","u","v"});
        values.put(9, new String[]{"w","x","y","z"});
        System.out.println(digits.charAt(0));
        String[] strs = values.get(digits.charAt(0));
        for (String str : strs) {
            System.out.println(str);
        }

        ret = Arrays.asList(values.get(digits.charAt(0)));

        if (len == 1) return ret;
        int i = 1; // 记录遍历到哪一个数字的下标了
        while(i < len) {
            List<String> temp = new ArrayList();
            // 如果是两个或者两个以上的数字，从第二个数字开始整理（开始的时候 ret 中已经有第一个数字的字符串集合了）
            for(String prev : ret) {
                // 前面数字的所有组成的字符串，考虑每一个字符串都加上一遍这个数字的
                for(String now : values.get(digits.charAt(i))) {
                    temp.add(prev + now);
                }
            }
            ret = temp;
            i++;
        }
        return ret;
    }


    public static void jisuan(int num) {
        int ge = num % 10;
        int shi = num % 100 / 10;
        int bai = num % 1000 / 100;
        int qian = num / 10000;
        System.out.println(ge);
        System.out.println(shi);
        System.out.println(bai);
        System.out.println(qian);
    }
    public static int maxArea(int[] height) {
        // 方法二（算法思路有问题，部分最后不是最大值）：先计算最边上的两个，然后依次向里面
        // （如果高度比两头都低就不看，高度大于较矮的那个就计算比较一下三者围成的三个面积）
        int left = 0;
        int right = height.length - 1;
        int k = 0; // left && right 是用来记录最大图形的两端下标，k 是来遍历的

        int maxArea = Math.min(height[left], height[right]) * (right - left);

        for(k = 1; k < height.length && k != left && k != right; k++) {
            // 比较三者值
            int area2 = Math.min(height[left], height[k]) * Math.abs(k - left);
            int area3 = Math.min(height[k], height[right]) * Math.abs(right - k);
            if (maxArea >= area2 && maxArea > area3) {
                continue;
            } else if (area2 > maxArea && area2 > area3) {
                right = k;
                maxArea = area2;
            } else {
                left = k;
                maxArea = area3;
            }
        }
        return maxArea;
    }
    public static boolean isMatch(String s, String p) {

        // 思路：双指针，依次移动
        int points = 0;
        int pointp = 0;
        char prev;

        // 第一个字符不可能是 '*'
        if (p.charAt(pointp) == '.') {
            pointp++;
            points++;
            prev = '.';
        } else {
            if (s.charAt(points) != p.charAt(pointp))
                return false;
            prev = s.charAt(points);
            pointp++;
            points++;
        }

        while (points < s.length() && pointp < p.length()) {
            // 先从 p 开始，如果 p 的字符是 '.'，两个指针都加一
            // 如果 p 的字符是 '*', 就判断 s 是否和 p 的前一个字符相同
            // （如果不相同就返回 false，否则就比较到不相同后，p 指针加一后再重新比较）
            if (p.charAt(pointp) == '.') {
                pointp++;
                points++;
                prev = '.';
            } else if (p.charAt(pointp) == '*') {
                if (prev == '.')
                    return true;
                if (s.charAt(points) != prev)
                    return false;
                // 一致比较，知道 s 不为 prev
                while (points < s.length() && s.charAt(points) == prev) {
                    points++;
                }
                pointp++;
            } else {
                // p 就是普通字符
                if (s.charAt(points) != p.charAt(pointp))
                    return false;
                prev = s.charAt(points);
                pointp++;
                points++;
            }
        }
        if (points == s.length() && pointp == p.length())
            return true;
        return false;

    }
}